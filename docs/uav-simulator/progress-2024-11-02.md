# UAV Network Simulator Progress — 2024-11-02 (Attack Experiments: DoS & Heartbeat Drop)

## Objective
- Validate that the PX4 ↔ QGroundControl link can be stressed with scripted attacks (bandwidth-flooding DoS and MAVLink Heartbeat drops) while ns-3-based shaping, telemetry capture, and JSON collection keep running.
- Produce synchronized datasets: raw PCAPNG, CSV summaries, and merged `/obs/latest` JSON that contain both network impairments and vehicle telemetry for AI/RL consumers.

## Components
| Layer | Role |
| --- | --- |
| **PX4 SITL + MAVROS** | Simulated UAV autopilot that emits MAVLink and ROS telemetry. |
| **QGroundControl** | GCS UI; connects to middleware on UDP 14640 (AutoConnect off). |
| **`udp_mw_ns3.py`** | UDP relay that injects ns-3 delay/loss/rate shaping, tallies 1 Hz byte counters, and POSTs them to `/ingest`. |
| **`alt2positions_light.py`** | Mirrors `/mavros/global_position/rel_alt` into `positions.txt` for ns-3. |
| **`mw-link-metrics` (ns-3)** | Converts altitude into link metrics (delay=10+h, loss=0.3·h, rate=6000−40·h, clipped). |
| **`collector.py`** | FastAPI service for `/ingest`, `/ingest_extra`, `/obs/latest`, `/obs/seq`. |
| **`ros_extra_pusher.py`** | Streams altitude, velocity, GNSS quality, heartbeat gap, and MAVLink Hz into `/ingest_extra`. |
| **`attackd.py` + `attackctl.py`** | Local controller/daemon that can spawn DoS floods or apply `tc netem` loss profiles to mimic Heartbeat drops. |
| **Capture Tools** | `start_capture.sh` / `stop_capture.sh` / `pcap_to_csv.sh` helpers that archive raw MAVLink packets. |

---

## Bring-up Sequence

Follow these steps to start the full simulation stack with data collection and attack capabilities.

### 1. Reset & Start Capture
Clear previous processes and start raw packet capture.

```bash
# Reset all UAV tools and processes
~/uav_tools/reset_all.sh

# Set Run ID and start capture on loopback interface
export RUN_ID="run_20231102"
IFACE=lo ~/uav_tools/start_capture.sh "$RUN_ID"
2. Collector & Attack DaemonStart the data collector service and the attack daemon.Bash# Start the FastAPI collector
~/uav_tools/start_collector.sh

# Start the attack daemon (background process)
python3 ~/mw_ns3/attackd.py --socket ~/.uav_ids/attackd.sock &
3. PX4 SITL & QGC WiringLaunch the flight simulator and configure the ground control station.Bashcd ~/PX4-Autopilot
PX4_NO_FORK=1 make px4_sitl_default none_iris
QGC Configuration:Disable UDP auto-listen (Port 14550).Add a new Comm Link: Server=127.0.0.1, Port=14640.4. ROS/MAVROS StackInitialize ROS and bridge it with the PX4 SITL.Bashsource /opt/ros/noetic/setup.bash

# Start ROS Core
roscore &

# Start MAVROS (connected to PX4)
rosrun mavros mavros_node _fcu_url:=udp://0.0.0.0:14556@127.0.0.1:14540 &
5. Altitude MirroringStart the script to mirror altitude data for ns-3.Bashexport NS3_PATH="$HOME/ns-allinone-3.35/ns-3.35"
python3 ~/mw_ns3/alt2positions_light.py &
6. Telemetry PushStart the service to push ROS telemetry to the collector.Bashexport IDS_EXTRA_ENDPOINT="[http://127.0.0.1:8080/ingest_extra](http://127.0.0.1:8080/ingest_extra)"
export RUN_ID="run_20231102"
python3 ~/mw_ns3/ros_extra_pusher.py &
7. MiddlewareLaunch the ns-3 based middleware to intercept and shape traffic.Bashexport IDS_ENDPOINT="[http://127.0.0.1:8080/ingest](http://127.0.0.1:8080/ingest)"
export RUN_ID="run_20231102"
python3 ~/mw_ns3/udp_mw_ns3.py --ns3-path "$NS3_PATH"
8. Baseline VerificationVerify that the system is running correctly.MAVROS State: Check if /mavros/state shows connected: True.Middleware Console: Should show logs like [MW] up:… down:… | delay≈10ms loss≈0%.Collector Check:Bashcurl -s [http://127.0.0.1:8080/obs/latest?k=3](http://127.0.0.1:8080/obs/latest?k=3) | python3 -m json.tool
Attack Automation (attackctl.py)Use attackctl.py to inject faults into the network.DoS FloodSends 800B payloads at 30 packets/s for 20 seconds to the target link.Bashpython3 ~/mw_ns3/attackctl.py dos 20 --payload-bytes 800 --pps 30 --target-port 14640 --tag link3
Heartbeat DropSimulates 60% packet loss on the heartbeat link for 15 seconds using tc netem.Bashpython3 ~/mw_ns3/attackctl.py hb 15 --loss 0.6 --iface lo
Status & StopCheck status or stop all attacks.Bash# Check status
python3 ~/mw_ns3/attackctl.py state

# Stop all attacks
python3 ~/mw_ns3/attackctl.py stop-all
Note: attackctl talks to the long-running attackd daemon via a UNIX socket; every command is logged to ~/.uav_ids/attackd.log.ObservationsDuring DoS: /obs/latest shows up_bytes/down_bytes spikes plus higher delay_ms/loss_pct.Heartbeat Drop: Causes hb_hz to fall (≈0.4–0.5 Hz) while heartbeat_gap_ms grows, confirming ROS telemetry captured the disruption.Synchronization: Middleware logs mirror the JSON stream, so PCAP/CSV timestamps can be aligned with sequence numbers.Data ArtifactsArtifactPathNotesRaw PCAP~/pcaps/${RUN_ID}.all.pcapngIncludes every MAVLink frame during attacks.CSV~/pcap_csv/${RUN_ID}.basic.csvExported via pcap_to_csv.sh.JSON/obs/latest or /obs/seqContains merged network metrics + telemetry.Local Log~/.uav_ids/flow.jsonlSame payload the middleware POSTs.Attack Log~/.uav_ids/attackd.logChronological record of DoS/HB events.TroubleshootingEmpty Endpoints: If /obs endpoints are empty, confirm collector + attack daemon are running and that RUN_ID matches on middleware and ROS pusher.Permission Errors: Heartbeat loss uses tc netem, so missing sudo privileges will raise warnings in attackd.log.File Conflicts: positions.txt being overwritten instantly indicates alt2positions_light.py is active; stop it before manual edits.Clean Up: Use ~/uav_tools/stop_capture.sh "$RUN_ID" followed by ~/uav_tools/pcap_to_csv.sh "$RUN_ID" to finalize artifacts before starting another run.Next StepsFeed the combined JSON + PCAP dataset into anomaly-detection or RL policies.Add more attack primitives (GPS spoof, uplink replay) by extending attackd.py.Automate labeling by tagging /ingest records with the active attack type.Testing⚠️ Not run (read-only QA scope).Appendix: mw_ns3/alt2positions_light.pyPython#!/usr/bin/env python3
"""
Lightweight helper that mirrors MAVROS relative altitude into ns-3's positions.txt.
"""

import argparse
import os
import pathlib
import signal
import sys
import threading
from typing import Optional

import rospy
from std_msgs.msg import Float64


class AltitudeWriter:
    def __init__(self, positions: pathlib.Path, topic: str, hz: float, precision: int) -> None:
        self._positions = positions
        self._tmp = positions.with_suffix(".tmp")
        self._precision = max(0, precision)
        self._lock = threading.Lock()
        self._altitude = 0.0

        self._positions.parent.mkdir(parents=True, exist_ok=True)
        self._cb_alt_sub = rospy.Subscriber(topic, Float64, self._cb_alt, queue_size=1)
        period = max(0.1, 1.0 / hz)
        self._timer = rospy.Timer(rospy.Duration(period), self._write)

        rospy.loginfo("alt2positions_light writing %s from %s at %.2f Hz", positions, topic, 1.0 / period)

    def _cb_alt(self, msg: Float64) -> None:
        with self._lock:
            self._altitude = max(0.0, float(msg.data))

    def _write(self, _event: rospy.timer.TimerEvent) -> None:
        with self._lock:
            altitude = round(self._altitude, self._precision)
        payload = f"0 0 0\n0 0 {altitude:.{self._precision}f}\n"
        try:
            with self._tmp.open("w", encoding="utf-8") as handle:
                handle.write(payload)
            self._tmp.replace(self._positions)
        except OSError as exc:
            rospy.logwarn("alt2positions_light failed to update %s: %s", self._positions, exc)


def parse_args() -> argparse.Namespace:
    default_ns3 = os.environ.get("NS3_PATH", os.path.expanduser("~/ns-allinone-3.35/ns-3.35"))
    parser = argparse.ArgumentParser(description="Mirror MAVROS altitude into positions.txt")
    parser.add_argument("--ns3-path", default=default_ns3, help="Base ns-3 directory (default: %(default)s)")
    parser.add_argument("--positions-file", help="Override positions.txt path (default: <ns3-path>/positions.txt)")
    parser.add_argument("--topic", default="/mavros/global_position/rel_alt", help="Altitude topic (default: %(default)s)")
    parser.add_argument("--hz", type=float, default=1.0, help="Write frequency in Hz (default: %(default)s)")
    parser.add_argument("--precision", type=int, default=2, help="Decimal places to store (default: %(default)s)")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    ns3_path = pathlib.Path(args.ns3_path).expanduser()
    positions = pathlib.Path(args.positions_file).expanduser() if args.positions_file else ns3_path / "positions.txt"

    rospy.init_node("alt2positions_light")
    AltitudeWriter(positions, args.topic, args.hz, args.precision)

    def _shutdown(_sig, _frame):
        rospy.loginfo("alt2positions_light shutting down")
        rospy.signal_shutdown("signal")

    signal.signal(signal.SIGINT, _shutdown)
    signal.signal(signal.SIGTERM, _shutdown)
    rospy.spin()
    return 0


if __name__ == "__main__":
    sys.exit(main())
