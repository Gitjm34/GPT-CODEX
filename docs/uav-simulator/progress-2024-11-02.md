# UAV Network Simulator Progress — 2024-11-02 (Attack Experiments: DoS & Heartbeat Drop)

## Objective
- Validate that the PX4 ↔ QGroundControl link can be stressed with scripted attacks (bandwidth-flooding DoS and MAVLink Heartbeat drops) while ns-3-based shaping, telemetry capture, and JSON collection keep running.
- Produce synchronized datasets: raw PCAPNG, CSV summaries, and merged `/obs/latest` JSON that contain both network impairments and vehicle telemetry for AI/RL consumers.

## Components
| Layer | Role |
| --- | --- |
| PX4 SITL + MAVROS | Simulated UAV autopilot that emits MAVLink and ROS telemetry. |
| QGroundControl | GCS UI; connects to middleware on UDP 14640 (AutoConnect off). |
| `udp_mw_ns3.py` | UDP relay that injects ns-3 delay/loss/rate shaping, tallies 1 Hz byte counters, and POSTs them to `/ingest`. |
| `alt2positions_light.py` | Mirrors `/mavros/global_position/rel_alt` into `positions.txt` for ns-3. |
| `mw-link-metrics` (ns-3) | Converts altitude into link metrics (delay=10+h, loss=0.3·h, rate=6000−40·h, clipped). |
| `collector.py` | FastAPI service for `/ingest`, `/ingest_extra`, `/obs/latest`, `/obs/seq`. |
| `ros_extra_pusher.py` | Streams altitude, velocity, GNSS quality, heartbeat gap, and MAVLink Hz into `/ingest_extra`. |
| `attackd.py` + `attackctl.py` | Local controller/daemon that can spawn DoS floods or apply `tc netem` loss profiles to mimic Heartbeat drops. |
| `start_capture.sh` / `stop_capture.sh` / `pcap_to_csv.sh` | tcpdump helpers that archive raw MAVLink packets and convert them for feature extraction.

## Bring-up Sequence
1. ** Reset & start capture**  
   ```bash
   ~/uav_tools/reset_all.sh
   export RUN_ID="run_20231102"
   IFACE=lo ~/uav_tools/start_capture.sh "$RUN_ID"
## Collector & attack daemon
```bash
   ~/uav_tools/start_collector.sh
   python3 ~/mw_ns3/attackd.py --socket ~/.uav_ids/attackd.sock &

## PX4 SITL & QGC wiring
```bash
cd ~/PX4-Autopilot
PX4_NO_FORK=1 make px4_sitl_default none_iris
In QGC: disable UDP auto-listen (14550), add Server=127.0.0.1, Port=14640.

ROS/MAVROS stack

bash
코드 복사
source /opt/ros/noetic/setup.bash
roscore &
rosrun mavros mavros_node _fcu_url:=udp://0.0.0.0:14556@127.0.0.1:14540 &
Altitude mirroring

bash
코드 복사
export NS3_PATH="$HOME/ns-allinone-3.35/ns-3.35"
python3 ~/mw_ns3/alt2positions_light.py &
Telemetry push

bash
코드 복사
export IDS_EXTRA_ENDPOINT="http://127.0.0.1:8080/ingest_extra"
export RUN_ID="run_20231102"
python3 ~/mw_ns3/ros_extra_pusher.py &
Middleware

bash
코드 복사
export IDS_ENDPOINT="http://127.0.0.1:8080/ingest"
export RUN_ID="run_20231102"
python3 ~/mw_ns3/udp_mw_ns3.py --ns3-path "$NS3_PATH"
Baseline verification

/mavros/state → connected: True

Middleware console prints [MW] up:… down:… | delay≈10ms loss≈0% rate≈6000kbps.

curl -s http://127.0.0.1:8080/obs/latest?k=3 | python3 -m json.tool

Attack Automation (attackctl.py)
DoS flood (20 s, 800 B payload, 30 packets/s, target ID 3 → default port set)

bash
코드 복사
python3 ~/mw_ns3/attackctl.py dos 20 --payload-bytes 800 --pps 30 --target-port 14640 --tag link3
Heartbeat drop (15 s, 60 % loss, loopback interface)

bash
코드 복사
python3 ~/mw_ns3/attackctl.py hb 15 --loss 0.6 --iface lo
Status / stop

bash
코드 복사
python3 ~/mw_ns3/attackctl.py state
python3 ~/mw_ns3/attackctl.py stop-all
attackctl talks to the long-running attackd daemon via a UNIX socket; every command is logged to ~/.uav_ids/attackd.log.

Observations
During DoS, /obs/latest shows up_bytes/down_bytes spikes plus higher delay_ms/loss_pct.

Heartbeat Drop causes hb_hz to fall (≈0.4–0.5 Hz) while heartbeat_gap_ms grows, confirming ROS telemetry captured the disruption.

Middleware logs mirror the JSON stream, so PCAP/CSV timestamps can be aligned with seq numbers.

Data Artifacts
Artifact	Where	Notes
Raw PCAP	~/pcaps/${RUN_ID}.all.pcapng	Includes every MAVLink frame during attacks.
CSV	~/pcap_csv/${RUN_ID}.basic.csv	Exported via pcap_to_csv.sh.
JSON	/obs/latest or /obs/seq	Contains merged network metrics + telemetry.
Local log	~/.uav_ids/flow.jsonl	Same payload the middleware POSTs.
Attack log	~/.uav_ids/attackd.log	Chronological record of DoS/HB events.

Troubleshooting
If /obs endpoints are empty, confirm collector + attack daemon are running and that RUN_ID matches on middleware and ROS pusher.

Heartbeat loss uses tc netem, so missing sudo privileges will raise warnings in attackd.log.

positions.txt being overwritten indicates alt2positions_light.py is active; stop it before manual edits.

Use ~/uav_tools/stop_capture.sh "$RUN_ID" followed by ~/uav_tools/pcap_to_csv.sh "$RUN_ID" to finalize artifacts before starting another run.

Next Steps
Feed the combined JSON + PCAP dataset into anomaly-detection or RL policies.

Add more attack primitives (GPS spoof, uplink replay) by extending attackd.py.

Automate labeling by tagging /ingest records with the active attack type.

Testing
⚠️ Not run (read-only QA scope)

python
코드 복사

---

## `mw_ns3/alt2positions_light.py`
```python
#!/usr/bin/env python3
"""
Lightweight helper that mirrors MAVROS relative altitude into ns-3's positions.txt.
"""

import argparse
import os
import pathlib
import signal
import sys
import threading
from typing import Optional

import rospy
from std_msgs.msg import Float64


class AltitudeWriter:
    def __init__(self, positions: pathlib.Path, topic: str, hz: float, precision: int) -> None:
        self._positions = positions
        self._tmp = positions.with_suffix(".tmp")
        self._precision = max(0, precision)
        self._lock = threading.Lock()
        self._altitude = 0.0

        self._positions.parent.mkdir(parents=True, exist_ok=True)
        rospy.Subscriber(topic, Float64, self._cb_alt, queue_size=1)
        period = max(0.1, 1.0 / hz)
        rospy.Timer(rospy.Duration(period), self._write)

        rospy.loginfo("alt2positions_light writing %s from %s at %.2f Hz", positions, topic, 1.0 / period)

    def _cb_alt(self, msg: Float64) -> None:
        with self._lock:
            self._altitude = max(0.0, float(msg.data))

    def _write(self, _event: rospy.timer.TimerEvent) -> None:
        with self._lock:
            altitude = round(self._altitude, self._precision)
        payload = f"0 0 0\n0 0 {altitude:.{self._precision}f}\n"
        try:
            with self._tmp.open("w", encoding="utf-8") as handle:
                handle.write(payload)
            self._tmp.replace(self._positions)
        except OSError as exc:
            rospy.logwarn("alt2positions_light failed to update %s: %s", self._positions, exc)


def parse_args() -> argparse.Namespace:
    default_ns3 = os.environ.get("NS3_PATH", os.path.expanduser("~/ns-allinone-3.35/ns-3.35"))
    parser = argparse.ArgumentParser(description="Mirror MAVROS altitude into positions.txt")
    parser.add_argument("--ns3-path", default=default_ns3, help="Base ns-3 directory (default: %(default)s)")
    parser.add_argument("--positions-file", help="Override positions.txt path (default: <ns3-path>/positions.txt)")
    parser.add_argument("--topic", default="/mavros/global_position/rel_alt", help="Altitude topic (default: %(default)s)")
    parser.add_argument("--hz", type=float, default=1.0, help="Write frequency in Hz (default: %(default)s)")
    parser.add_argument("--precision", type=int, default=2, help="Decimal places to store (default: %(default)s)")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    ns3_path = pathlib.Path(args.ns3_path).expanduser()
    positions = pathlib.Path(args.positions_file).expanduser() if args.positions_file else ns3_path / "positions.txt"

    rospy.init_node("alt2positions_light")
    AltitudeWriter(positions, args.topic, args.hz, args.precision)

    def _shutdown(_sig, _frame):
        rospy.loginfo("alt2positions_light shutting down")
        rospy.signal_shutdown("signal")

    signal.signal(signal.SIGINT, _shutdown)
    signal.signal(signal.SIGTERM, _shutdown)
    rospy.spin()
    return 0


if __name__ == "__main__":
    sys.exit(main())
